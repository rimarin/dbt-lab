package de.tuberlin.dima.minidb.optimizer;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import de.tuberlin.dima.minidb.api.AbstractExtensionFactory;
import de.tuberlin.dima.minidb.catalogue.Catalogue;
import de.tuberlin.dima.minidb.catalogue.IndexDescriptor;
import de.tuberlin.dima.minidb.catalogue.TableDescriptor;
import de.tuberlin.dima.minidb.core.DataType;
import de.tuberlin.dima.minidb.core.InternalOperationFailure;
import de.tuberlin.dima.minidb.io.cache.PageSize;
import de.tuberlin.dima.minidb.io.tables.TablePage;
import de.tuberlin.dima.minidb.optimizer.cardinality.CardinalityEstimator;
import de.tuberlin.dima.minidb.optimizer.cost.CostEstimator;
import de.tuberlin.dima.minidb.optimizer.generator.PhysicalPlanGenerator;
import de.tuberlin.dima.minidb.optimizer.joins.JoinOrderOptimizer;
import de.tuberlin.dima.minidb.parser.OrderColumn;
import de.tuberlin.dima.minidb.parser.Predicate;
import de.tuberlin.dima.minidb.parser.OutputColumn.AggregationType;
import de.tuberlin.dima.minidb.qexec.heap.QueryHeap;
import de.tuberlin.dima.minidb.semantics.AnalyzedSelectQuery;
import de.tuberlin.dima.minidb.semantics.BaseTableAccess;
import de.tuberlin.dima.minidb.semantics.Column;
import de.tuberlin.dima.minidb.semantics.Order;
import de.tuberlin.dima.minidb.semantics.ProducedColumn;
import de.tuberlin.dima.minidb.semantics.Relation;
import de.tuberlin.dima.minidb.semantics.predicate.JoinPredicate;
import de.tuberlin.dima.minidb.semantics.predicate.JoinPredicateAtom;
import de.tuberlin.dima.minidb.semantics.predicate.JoinPredicateConjunct;
import de.tuberlin.dima.minidb.semantics.predicate.LocalPredicate;
import de.tuberlin.dima.minidb.semantics.predicate.LocalPredicateAtom;
import de.tuberlin.dima.minidb.semantics.predicate.LocalPredicateBetween;
import de.tuberlin.dima.minidb.semantics.predicate.LocalPredicateConjunct;


/**
 * The optimizer root class. This class gets an analyzed query and finds for it the
 * best optimizer plan describing a specific strategy to execute that query.
 * <p>
 * The optimizer works cost based, restricting itself to cardinalities and I/O costs.
 * Plans are hence generated by a set of rules and then compared and pruned based
 * on cost metrics.
 * 
 * @author Stephan Ewen (stephan.ewen@tu-berlin.de)
 */
@SuppressWarnings("unused")
public class Optimizer
{
	/**
	 * The catalogue used to determine the availability of indexes.
	 */
	private Catalogue catalogue;
	
	/**
	 * The estimator used to determine table access and join cardinalities.
	 */
	private CardinalityEstimator cardEstimator;
	
	/**
	 * The cost estimator for physical operators.
	 */
	private CostEstimator costEstimator;
	
	
	/**
	 * Creates a new optimizer that tries to find the best plan with respect to the given
	 * parameters.
	 * 
	 * @param catalogue The catalogue used to determine the availability of indexes.
	 * @param readCost The default time (nanoseconds) that is needed to transfer a block of the
	 *                  default block size from secondary storage to main memory.
	 * @param writeCost The default time (nanoseconds) that is needed to transfer a block of the
	 *                  default block size from main memory to secondary storage.
	 * @param randomReadOverhead The overhead for a single block read operation if the block is
	 *                           not part of a sequence that is read. For magnetic disks, that 
	 *                           would correspond to seek time + rotational latency.
	 * @param randomWriteOverhead The overhead for a single block write if the block is not part 
	 *                            of a sequence that is written. For magnetic disks, that would 
	 *                            correspond to seek time + rotational latency.
	 */
	public Optimizer(Catalogue catalogue, long readCost, long writeCost, 
			long randomReadOverhead, long randomWriteOverhead)
	{
		this.catalogue = catalogue;
		this.cardEstimator = AbstractExtensionFactory.getExtensionFactory().createCardinalityEstimator();
		try{
			this.costEstimator = AbstractExtensionFactory.getExtensionFactory().createCostEstimator(readCost, writeCost, randomReadOverhead, randomWriteOverhead);
		}catch (UnsupportedOperationException e){
			this.costEstimator = null;
		}
	}

	/**
	 * Takes the analyzed select-query and finds the best query execution plan in this
	 * optimizers plan-space. The plan is returned as a tree of plan operators. 
	 * 
	 * @param query The analyzed query that the best plan is to be created for.
	 * @return The best plan for this query, as found by the optimizer.
	 * @throws OptimizerException Thrown, if the optimizer encountered an error, if if the verifier declares the plan
	 *                            incorrect.
	 */
	public OptimizerPlanOperator createSelectQueryPlan(AnalyzedSelectQuery query) throws OptimizerException
	{
		return createSelectQueryPlan(query, null);
	}

	/**
	 * Takes the analyzed select-query and finds the best query execution plan in this
	 * optimizers plan-space. The plan is returned as a tree of plan operators. 
	 * 
	 * @param query The analyzed query that the best plan is to be created for.
	 * @param verifyer A join order verifier that is invoked after the join order optimization phase.
	 *                 If null is given as this parameter, then no verification takes place.
	 * 
	 * @return The best plan for this query, as found by the optimizer.
	 * @throws OptimizerException Thrown, if the optimizer encountered an error, if if the verifier declares the plan
	 *                            incorrect.
	 */
	public OptimizerPlanOperator createSelectQueryPlan(AnalyzedSelectQuery query, JoinOrderVerifier verifyer)
	throws OptimizerException
	{
		return createSelectQueryPlan(query, verifyer, false);
	}
	
	/**
	 * Takes the analyzed select-query and finds the best query execution plan in this
	 * optimizers plan-space. The plan is returned as a tree of plan operators. 
	 * 
	 * @param query The analyzed query that the best plan is to be created for.
	 * @param verifyer A join order verifier that is invoked after the join order optimization phase.
	 *                 If null is given as this parameter, then no verification takes place.
	 * 
	 * @return The best plan for this query, as found by the optimizer.
	 * @throws OptimizerException Thrown, if the optimizer encountered an error, if if the verifier declares the plan
	 *                            incorrect.
	 */
	public OptimizerPlanOperator createSelectQueryPlan(AnalyzedSelectQuery query, JoinOrderVerifier verifyer, boolean joinOrderOnly)
	throws OptimizerException
	{
		/* ********************************************************************
		 * Base Cardinality Estimation
		 * 
		 * The first step in the optimizer is to build cardinality estimates
		 * for the table accesses with the local predicates.
		 * ********************************************************************/
		
		Relation[] relations = query.getTableAccesses();
		for (int i = 0; i < relations.length; i++) {
			Relation r = relations[i];
			if (r instanceof BaseTableAccess) {
				// 
				this.cardEstimator.estimateTableAccessCardinality((BaseTableAccess) r);
			}
			else if (r instanceof AnalyzedSelectQuery) {
				// recursively create the plan for this query
				AnalyzedSelectQuery subQuery = (AnalyzedSelectQuery) r;
				OptimizerPlanOperator planRoot = createSelectQueryPlan(subQuery, verifyer, true);
				
				subQuery.setQueryPlan(planRoot);
				
				// compute the output cardinality of the grouping operator
				// it is the lower of the input cardinality and the product of
				// the group column cardinalities
				ProducedColumn[] pc = subQuery.getOutputColumns();
				
				if (subQuery.isGrouping()) {
					long outCard = 1;
					for (int k = 0; k < pc.length; k++) {
						ProducedColumn col = pc[k];
						if (col.getAggregationFunction() != AggregationType.NONE) {
							continue;
						}
						
						Relation rel = col.getRelation();
						long card = 0;
						if (rel instanceof BaseTableAccess) {
							card = ((BaseTableAccess) rel).getTable().getStatistics().getColumnStatistics(col.getColumnIndex()).getCardinality();
						}
						else if (rel instanceof AnalyzedSelectQuery) {
							card = ((AnalyzedSelectQuery) r).getOutputCardinality();
						}
						outCard *= card;
					}
					outCard = Math.min(outCard, planRoot.getOutputCardinality());
					subQuery.setOutputCardinality(outCard);
				}
			}
			else {
				throw new IllegalStateException("Unknown type of relation.");
			}
		}
		
		/* ********************************************************************
		 * Join Order
		 * 
		 * The next step is to determine the join order, based only on
		 * cardinality estimates.
		 * ********************************************************************/

		JoinOrderOptimizer joo = AbstractExtensionFactory.getExtensionFactory().createJoinOrderOptimizer(this.cardEstimator);
//		JoinOrderOptimizer joo = new de.tuberlin.dima.minidb.optimizer.joins.JoinOrderOptimizerRefImpl(cardEstimator);
		OptimizerPlanOperator bestJoinOrder = joo.findBestJoinOrder(query.getTableAccesses(), query.getJoinEdges());
		
		// optional verification phase for testing purposes.
		if (verifyer != null) {
			verifyer.verifyJoinOrder(query, bestJoinOrder);
		}
		
		if (joinOrderOnly) {
			return bestJoinOrder;
		}
		
		/* ********************************************************************
		 * Top Down Plan Generation
		 * 
		 * The optimizer plan is now generated top down, starting at the
		 * root operator which has the final output properties.
		 * ********************************************************************/
		
		PhysicalPlanGenerator planGenerator = AbstractExtensionFactory.getExtensionFactory().createPhysicalPlanGenerator(this.catalogue, this.cardEstimator, this.costEstimator);
		
		OptimizerPlanOperator bestPlan = planGenerator.generatePhysicalPlan(query, bestJoinOrder);
		query.setQueryPlan(bestPlan);
		return bestPlan;
	}
}
